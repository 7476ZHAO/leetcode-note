key:
  way to reduce the comparation time
    1. to reduce the time of comparation, sorting needed.
    2. when the min sum more than target, means all quadraplets greater than target, break, no such quadraplets exist
    3. when the max sum less than target, means all quadraplets in the current loop less than target, continue. This step reduce the comparation time a lot.
  ways to make sure the quadraplet unique
    in every loop, make sure nums[i] != nums[i-1], if not, skip current i. and j, lo, hi also need to check.
  
# class Solution:
#     def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        sum_list = []

        for i in range(len(nums)-3):

            #prevent the same element appearing again in the same position of quadruplet
            #then make sure every quadruplet unique 
            if i > 0 and nums[i] == nums[i-1]:
                continue
            
            min_sum = nums[i] + nums[i+1] + nums[i+2] + nums[i+3]
            if min_sum > target:
                break

            max_sum = nums[i] + nums[len(nums)-1] + nums[len(nums)-2] + nums[len(nums)-3]
            if max_sum < target:
                continue

            for j in range(i+1, len(nums)-2):

                #prevent the same element appearing again in the same position of quadruplet
                #then make sure every quadruplet unique
                if j > i+1 and nums[j] == nums[j-1]:
                    continue
                
                min_s = nums[i] + nums[j] + nums[j+1] + nums[j+2]
                if min_s > target:
                    break

                max_s = nums[i] + nums[j] + nums[len(nums)-1] + nums[len(nums)-2]
                if max_s < target:
                    continue            

                lo, hi = j+1, len(nums)-1

                while lo < hi:
                    sum_num = nums[i] + nums[j] + nums[lo] + nums[hi]

                    if sum_num < target:
                        lo += 1                    
                    elif sum_num > target:
                        hi -= 1                        
                    else:
                        # if [nums[i], nums[j], nums[lo], nums[hi]] not in sum_list:
                        sum_list.append([nums[i], nums[j], nums[lo], nums[hi]])

                        lo += 1
                        while lo < hi and nums[lo] == nums[lo-1]:#prevent quadruplets overlapping and lo in the span of index
                            lo += 1
                        hi -= 1
                        while lo < hi and nums[hi] == nums[hi+1]:#prevent quadruplets overlapping and lo in the span of index
                            hi -= 1                     
        return sum_list
                  

                        
                       


            
